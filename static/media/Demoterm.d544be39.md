Last modified: December 18th, 2020.

you can check live demo as follows:  
[![](http://img.youtube.com/vi/IgnIqqi7Inc/0.jpg)](http://www.youtube.com/watch?v=IgnIqqi7Inc)
<img src="/docimage/demoterm-3.png" width="800">

## 1. Overview

<img src="/docimage/demoterm-1.png" width="800">

In remote serial control, it is important to protect the communication path in order to completely control the remote target device.  
Needless to say, various authentication information such as login password is typed in.

Such applications require mutual authentication on all routes from the device to the server and to the web cients.

In this scenario, we will use the ESP32 with rainbowtype configured to transfer serial communication with the target device to the server via websocket so that it can be operated from the browser console.

I created a boilerplate that provides both the ability to receive and route websockets from the device and the ability to display them on the browser side.  
It's set in the Dockerfile, so all you have to do is have a server with a static IP that the device can point to.  
A simple example is google compute engine.

<img src="/docimage/demoterm-2.png" width="800">

On the server side, we provide a page composed of React to the WEB client.  
It also incorporates [Xterm.js](https://xtermjs.org/), which provides a great terminal user interface.  
It has a lot of real use cases such as Microsoft Visual Studio Code.

## 2. Server side boilerplate

Deploy the boilerplate on the server with the static IP.

```
git clone https://github.com/kmwebnet/rtapptest-xterm.git
```

Then, place the server certificate, root CA certificate, and signer CA certificate generated by rainbowtype.

```
cp -R certs/* rtapptest-xterm/certs/
cd rtapptest-xterm
```

build and run docker image

```
sudo docker build --tag=kmitsu/rtapptest-xterm .
sudo docker run -v $PWD/certs:/usr/src/app/certs -dit --rm -p 5000:5000 --name rtapptest-xterm kmitsu/rtapptest-xterm
```

You can find terminal app under /sub page.  
<img src="http://img.youtube.com/vi/IgnIqqi7Inc/0.jpg">

Web terminal code is just simple with Xterm.js's help as below.  
You can seamlessly connect Websocket transmission and reception to the terminal area.

```
import React, { useEffect, useRef } from 'react';
import { makeStyles, createStyles, Theme } from "@material-ui/core/styles";
import { Terminal } from 'xterm';
import 'xterm/css/xterm.css';
import { AttachAddon } from 'xterm-addon-attach'

const useStyles = makeStyles((theme: Theme) =>
  createStyles({
    appBarSpacer: theme.mixins.toolbar,
  })
);


function SubComponent() {

  const wsUrl = 'wss://' + window.location.host + '/ws';
  const terminalRef = useRef<HTMLDivElement>(null);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const xterm = new Terminal({
    cursorBlink: true,
    fontFamily: "Consolas, 'Courier New', monospace",
  })

  useEffect(() => {
    if(terminalRef.current && !terminalRef.current.children.length) {
      xterm.open(terminalRef.current)
      const ws = new WebSocket(wsUrl);
      xterm.focus()

      ws.onopen = () => {
        xterm.loadAddon(new AttachAddon(ws))
      }
      ws.onerror = (e) =>  { console.log(e) }
      ws.onclose = () => {
        const red = `\x1b[31m`
        xterm.writeln('\n' + red + 'WEBSOCKET DISCONNECTED')
        xterm.setOption('disableStdin', true)
      }
    }
  }, [xterm, terminalRef, wsUrl])
  useEffect(() => () => xterm.dispose(), [xterm]) ;

  const classes = useStyles();
    return (
      <>
        <div className={classes.appBarSpacer} />
        <div  ref={terminalRef} id='terminal'></div>
      </>
    );
}

export default SubComponent;
```

## 3. Device side code

The device side is programmed with Arduino.

You can find the rainbowtype-arduino-boilerplate on [this link](https://github.com/kmwebnet/rainbowtype-arduino-boilerplate).  
You need to setup this repo as zip at Arduino library manager. Then, you'll find "WebSocketserial" in example sketches.

and you must copy "cert_chain.c" which you have generated one by rainbowtype client.

you need to modify the constants which you already have as follows:

```
mqttClient.setServer("XXXXXXXXXXXXX-ats.iot.us-east-1.amazonaws.com", 8883); on "connectAWS"

const char* root_ca = "";  on "WebSocketserial", "WebSocketcamera"
webSocket.beginSslWithCA(<URL>, 5000, "/ws", root_ca); on "WebSocketserial", "WebSocketcamera"
```

The rainbowtype library overrides the wificlientsecure library to communicate using  
the hardware root of trust for TLS communication and read the wifi connection information.  
Notice that we didn't write any sensitive information in the code  
other than the root CA certificate and the destination URL.

```
[code]
#include <Arduino.h>
#include <WiFi.h>
#include <rainbowtype.h>
#include <WebSocketsClient_Generic.h>
#include <HardwareSerial.h>

HardwareSerial ser(2);

char CLIENT_ID[18];

char wifissid[32];
char wifipass[64];

const char* root_ca = \
"-----BEGIN CERTIFICATE-----\n" \
...
"-----END CERTIFICATE-----\n";

WebSocketsClient webSocket;

char serbuf[8000];
char wsbuf[2000];
size_t serbuflen = 0;
size_t wsbuflen = 0;

portMUX_TYPE myMutex = portMUX_INITIALIZER_UNLOCKED;


void webSocketEvent(WStype_t type, uint8_t * payload, size_t length)
{
  switch (type)
  {
    case WStype_DISCONNECTED:
      Serial.printf("[WSc] Disconnected!\r\n");
      break;
    case WStype_CONNECTED:
      Serial.printf("[WSc] Connected to url: %s\r\n", payload);

      // send message to server when Connected
      webSocket.sendTXT("Connected");
      break;

    case WStype_TEXT:
      if (length == 0) break;
      payload[length] = 0;
       taskENTER_CRITICAL_ISR(&myMutex);
        memcpy(&wsbuf[wsbuflen], payload, length);
        wsbuflen += length;
       taskEXIT_CRITICAL_ISR(&myMutex);
      break;
    case WStype_BIN:
      break;
    case WStype_ERROR:
    case WStype_FRAGMENT_TEXT_START:
    case WStype_FRAGMENT_BIN_START:
    case WStype_FRAGMENT:
    case WStype_FRAGMENT_FIN:
      break;

    default:
      break;
  }
}

void serialtask(void* param) {
  ser.begin(115200, SERIAL_8N1, 18, 19 );
  while (!ser);
  Serial.println("serial init..\r\n");
  while (1)
  {
   int len = ser.available();
   if (len > 0) {
    taskENTER_CRITICAL_ISR(&myMutex);
    for (int i=0; i < len; i++){
      serbuf[serbuflen] = ser.read();
      serbuflen ++;
    }
    serbuf[serbuflen] = 0;
    taskEXIT_CRITICAL_ISR(&myMutex);

   }
   if (wsbuflen > 0){
     ser.write((const uint8_t *)wsbuf, wsbuflen);
     wsbuflen = 0;
   }
     delay(1) ;

  }
}

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  while (!Serial);

  Serial.println("\nStart ESP32_WebSocketClientSSL on " + String(ARDUINO_BOARD));

  getid(CLIENT_ID);
  wifiinit(wifissid, wifipass);

  WiFi.begin(wifissid, wifipass);
  while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      Serial.print(".");
  }
  Serial.println("Connected.\r\n");


  xTaskCreatePinnedToCore(serialtask, "Task0", 4096, NULL, 1, NULL, 0);

  webSocket.beginSslWithCA("<url>", 5000, "/ws", root_ca);
  webSocket.onEvent(webSocketEvent);
}

void loop() {
  // put your main code here, to run repeatedly:

  // waiting for recieving data
  webSocket.loop();
  if (serbuflen > 0) {
    webSocket.sendBIN((const uint8_t *)serbuf, serbuflen);
    serbuflen = 0;
  }
    delay(1) ;

}
[/code]
```

## 4. Upload & test

Instead of the usual Arduino build, use "Export compiled Binary" option.  
<img src="/docimage/demoterm-4.png" width="800">

Once firmware has built on Arduino IDE, it's ready to transfer it to the device.  
You can transfer it by rainbowtype client.  
Narrow down to your target device ID's "DEVICE SETTING" button.

<img src="/docimage/demoterm-5.png" width="800">

Set request to "ota", and choose template.  
then, you can get "SELECT FW FILE..." button.

<img src="/docimage/demoterm-6.png" width="800">

Point your binaries built on above steps.

<img src="/docimage/demoterm-7.png" width="800">

If you find "UPLOAD SUCCESS.", you can set it to press "CHANGE".

<img src="/docimage/demoterm-8.png" width="800">

Reset device with keeping GPIO 15 button down, and enter rainbowtype bootloader.  
it invokes OTA function and fetch uploaded firmware.

you can check live demo as follows:

[![](http://img.youtube.com/vi/IgnIqqi7Inc/0.jpg)](http://www.youtube.com/watch?v=IgnIqqi7Inc)
