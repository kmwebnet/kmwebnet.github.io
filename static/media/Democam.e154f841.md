Last modified: December 18th, 2020.

you can check live demo as follows:  
[![](http://img.youtube.com/vi/V85D79XiV2E/0.jpg)](http://www.youtube.com/watch?v=V85D79XiV2E)
<img src="/docimage/democam-1.jpg" width="800">

## 1. Overview

<img src="/docimage/democam-2.png" width="800">

In surveillance camera applications, it is important to protect the communication path to protect privacy.

Such applications require mutual authentication on all routes from the device to the server and to the website.

This scenario uses a rainbow-type ESP32 configured to transfer the camera image of the target device to the server via WebSocket to display multiple camera images in the browser.

I have created a boilerplate that provides both the ability to receive and route WebSockets from devices and the ability to display them on the browser side.  
This is set in the Dockerfile, so all you have to do is provide a server with a static IP that the device can point to.  
A simple example is the Google computing engine, but you need to pay attention to the billing situation because image transfer uses a lot of bandwidth.

<img src="/docimage/democam-3.png" width="800">

On the server side, a page consisting of React is provided to the WEB client.  
Add ID information to route images from multiple devices and assign it to WEB components.

## 2. Server side boilerplate

Deploy the boilerplate on the server with the static IP.

```
git clone https://github.com/kmwebnet/rainbowtype-apptest-webcam.git
```

Then, place the server certificate, root CA certificate, and signer CA certificate generated by rainbowtype.

```
cp -R certs/* rainbowtype-apptest-webcam/certs/
cd rainbowtype-apptest-webcam
```

build and run docker image

```
sudo docker build --tag=kmitsu/rtapptest-webcam .
sudo docker run -v $PWD/certs:/usr/src/app/certs -dit --rm -p 5000:5000 --name rtapptest-webcam kmitsu/rtapptest-webcam
```

You can find terminal app under /sub2 page.  
<img src="http://img.youtube.com/vi/V85D79XiV2E/0.jpg">

As shown below, increase the img component as the number of connections increases,  
and use React's useRef to update the jpeg data.

```
import React, { useState, useEffect, useRef } from 'react';

function SubComponent2() {
  const wsUrl = 'wss://' + window.location.host + '/ws';
  const ws = useRef(new WebSocket(wsUrl));
  ws.current.binaryType = 'arraybuffer';
  const imgref = useRef<Array<HTMLImageElement>>([]);
  const serial: string[] = [];
  const [ser, setser] = useState<string[]>([]);

  useEffect(() => {
    ws.current.onmessage = (ev: MessageEvent) => {
      if (ev.data) {
        const tserial: string = String.fromCharCode(
          ...new Uint8Array(ev.data.slice(-18))
        );
        if (tserial.slice(0, 4) === '0123') {
          if (!serial.some((e) => e === tserial)) {
            serial.push(tserial);
            imgref.current.push(new Image());
            setser((ser) => [...ser, tserial]);
          }
          const idx = serial.indexOf(tserial);
          const cref = imgref.current[idx];
          if (cref && cref.complete) {
            cref.src =
              'data:image/jpg;base64,' +
              window.btoa(
                String.fromCharCode(...new Uint8Array(ev.data.slice(0, -18)))
              );
          }
        }
      }
    };
  }, []);
  useEffect(() => () => ws.current.close(), [ws]);

  return (
    <div>
      <h2>{window.location.host}</h2>
      <h2>Multi Camera Demo</h2>
      {ser.map((v, i) => (
        <div key={v}>
          <img
            key={v}
            ref={(el) => (imgref.current[i] = el as HTMLImageElement)}
            src=""
          />
          <h2 key={v}>
            CAMERA{i} {v}
          </h2>
        </div>
      ))}
    </div>
  );
}

export default SubComponent2;
```

## 3. Device side code

The device side is programmed with Arduino.

You can find the rainbowtype-arduino-boilerplate on [this link](https://github.com/kmwebnet/rainbowtype-arduino-boilerplate).  
You need to setup this repo as zip at Arduino library manager. Then, you'll find "WebSocketcamera" in example sketches.

and you must copy "cert_chain.c" which you have generated one by rainbowtype client.

you need to modify the constants which you already have as follows:

```
mqttClient.setServer("XXXXXXXXXXXXX-ats.iot.us-east-1.amazonaws.com", 8883); on "connectAWS"

const char* root_ca = "";  on "WebSocketserial", "WebSocketcamera"
webSocket.beginSslWithCA(<URL>, 5000, "/ws", root_ca); on "WebSocketserial", "WebSocketcamera"
```

The rainbowtype library overrides the wificlientsecure library to communicate using  
the hardware root of trust for TLS communication and read the wifi connection information.  
Notice that we didn't write any sensitive information in the code  
other than the root CA certificate and the destination URL.

```
[code]
#include <Arduino.h>
#include <WiFi.h>
#include <rainbowtype.h>

#include <WebSocketsClient_Generic.h>
#include "esp_camera.h"

char CLIENT_ID[18];

char wifissid[32];
char wifipass[64];

const char* root_ca = \
"-----BEGIN CERTIFICATE-----\n" \
...
"-----END CERTIFICATE-----\n";

WebSocketsClient webSocket;

bool connected = false;

void webSocketEvent(WStype_t type, uint8_t * payload, size_t length)
{
  switch (type)
  {
    case WStype_DISCONNECTED:
      Serial.printf("Disconnected!\r\n");
      connected = false;
      break;
    case WStype_CONNECTED:
      Serial.printf("Connected to url: %s\r\n", payload);
      connected = true;
      break;

    case WStype_TEXT:
      break;
    case WStype_BIN:
      break;
    case WStype_ERROR:
    case WStype_FRAGMENT_TEXT_START:
    case WStype_FRAGMENT_BIN_START:
    case WStype_FRAGMENT:
    case WStype_FRAGMENT_FIN:
      break;

    default:
      break;
  }
}

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  while (!Serial);

  Serial.println("\nStart ESP32_WebSocketClientSSL on " + String(ARDUINO_BOARD));



  getid(CLIENT_ID);
  wifiinit(wifissid, wifipass);

  WiFi.begin(wifissid, wifipass);
  while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      Serial.print(".");
  }
  Serial.print("Connected.\r\n");

  webSocket.beginSslWithCA(<URL>, 5000, "/ws", root_ca);
  webSocket.onEvent(webSocketEvent);

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = 2;
  config.pin_d1 = 5;
  config.pin_d2 = 18;
  config.pin_d3 = 19;
  config.pin_d4 = 36;
  config.pin_d5 = 39;
  config.pin_d6 = 34;
  config.pin_d7 = 35;
  config.pin_xclk = 32;
  config.pin_pclk = 33;
  config.pin_vsync = 25;
  config.pin_href = 23;
  config.pin_sscb_sda = 26;
  config.pin_sscb_scl = 27;
  config.pin_pwdn = -1;
  config.pin_reset = 14;
  config.xclk_freq_hz = 6000000; // 6000000
  config.pixel_format = PIXFORMAT_JPEG;

  if(psramFound()){
    config.frame_size = FRAMESIZE_VGA; // VGA
    config.jpeg_quality = 1; //9
    config.fb_count = 8; //8
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }

  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;

  sensor_t * s = esp_camera_sensor_get();
  //drop down frame size for higher initial frame rate
  s->set_framesize(s, FRAMESIZE_QVGA);

  Serial.printf("free heap size: %d\r\n", xPortGetFreeHeapSize() );
}
}



void loop() {
      webSocket.loop();

    if(connected) {
      camera_fb_t *fb = esp_camera_fb_get();
        if(!fb){
          Serial.println("Camera capture failed");
          esp_camera_fb_return(fb);
        return;
        }

      if(fb->format != PIXFORMAT_JPEG){
        Serial.println("Non-JPEG data not implemented");
        return;
      }
    // Serial.printf("fb size: %d\r\n", fb->len );
    size_t dlen = fb->len -1;
    for (int i=0; i < dlen; i++){
      if (fb->buf[i] == 0xff && fb->buf[i + 1] == 0xd9)
      {
        webSocket.sendBIN((const uint8_t *) fb->buf, i + 2);
        break;
      }
    };

    esp_camera_fb_return(fb);
    }

}
[/code]
```

## 4. Upload & test

Instead of the usual Arduino build, use "Export compiled Binary" option.  
<img src="/docimage/democam-4.png" width="800">

Once firmware has built on Arduino IDE, it's ready to transfer it to the device.  
You can transfer it by rainbowtype client.  
Narrow down to your target device ID's "DEVICE SETTING" button.

<img src="/docimage/demoterm-5.png" width="800">

Set request to "ota", and choose template.  
then, you can get "SELECT FW FILE..." button.

<img src="/docimage/demoterm-6.png" width="800">

Point your binaries built on above steps.

<img src="/docimage/democam-5.png" width="800">

If you find "UPLOAD SUCCESS.", you can set it to press "CHANGE".

<img src="/docimage/demoterm-8.png" width="800">

Reset device with keeping GPIO 15 button down, and enter rainbowtype bootloader.  
it invokes OTA function and fetch uploaded firmware.

Upload the firmware from the rainbowtype client in the same way for the second and subsequent units.

you can check live demo as follows:

[![](http://img.youtube.com/vi/V85D79XiV2E/0.jpg)](http://www.youtube.com/watch?v=V85D79XiV2E)
